#target photoshop#include common.js/* global activeDocument, ElementPlacement, app, ActionDescriptor, executeAction, charIDToTypeID, DialogModes */var CSV_ID = 'csv';var WRITE_TO_CSV = true;//var MAKE_BACKGROUND = true;var DO_RESIZE = true;// разница между `y` нижней границы модуля и `y` верхней границы черного прямоугольникаvar BOTTOM_RECT_UP = 20;// разница между `y` нижней границы модуля и `y` нижней границы черного прямоугольникаvar BOTTOM_RECT_BOTTOM = 30;// разница между `x` правой границы модуля и `x` правой границы черного прямоугольникаvar BOTTOM_RECT_RIGHT = 20;// разница между `x` правой границы модуля и `x` левой границы черного прямоугольникаvar RIGHT_RECT_LEFT = 20;// разница между `x` правой границы модуля и `x` правой границы черного прямоугольникаvar RIGHT_RECT_RIGHT = 20;// разница между `y` нижней границы модуля и `y` нижней границы черного прямоугольникаvar RIGHT_RECT_BOTTOM = 40;// разница между `y` верхней границы модуля и `y` верхней границы черного прямоугольникаvar RIGHT_RECT_UP = 10;/** Требования: Cлои для обработки должны называться десятичной цифрой без букв. Слой с фоном должен называться `fon`. Нужно создать подпапку `_` в папке, где лежат PSD. */var BG_LAYER_NAME = 'bg';var CANVAS_LAYER_NAME = 'canvas';var ORIENTATION = {  UP: 0,  DOWN: 1,  LEFT: 2,  RIGHT: 3};// величина обрезки угла слоя/*var LAYER_CORNER_CROP = 10;*//** * Обрабатывает целевой слой: добавляет тень, обрезает углы. * @param {ArtLayer} layer * @returns {ArtLayers[]} созданные в процессе слои */function processModularLayer(layer, bg) {  var canvasLayer = this.createTextureLayer(PATH_TO_CANVAS, BG_LAYER_NAME + '_' + layer.name);  /*   (x, y) верхнего левого угла   (x, y) нижнего правого угла   */  var bounds = layer.boundsNoEffects;  /*   Создаем новый слой и помещаем его под слой, который обрабатываем   */  var rectLayer = activeDocument.artLayers.add();  rectLayer.name = layer.name + '_' + 'shadow';  rectLayer.move(bg, ElementPlacement.PLACEBEFORE);  activeDocument.activeLayer = rectLayer;  /*   Выделяем область для нижнего черного прямоугольника   */  var left = bounds[0].value;  var top = bounds[1].value;  var right = bounds[2].value;  var bottom = bounds[3].value;  var bottomRectCoords = [    [left, bottom - BOTTOM_RECT_UP],    [right - RIGHT_RECT_LEFT, bottom - BOTTOM_RECT_UP],    [right - RIGHT_RECT_LEFT, bottom + BOTTOM_RECT_BOTTOM],    [left, bottom + BOTTOM_RECT_BOTTOM]  ];  createRectAndFillWithBlack(rectLayer, bottomRectCoords);  var rightRectCoords = [    [right - RIGHT_RECT_LEFT, top - RIGHT_RECT_UP],    [right + RIGHT_RECT_RIGHT, top - RIGHT_RECT_UP],    [right + RIGHT_RECT_RIGHT, bottom + BOTTOM_RECT_BOTTOM],    [right - RIGHT_RECT_LEFT, bottom + BOTTOM_RECT_BOTTOM]  ];  createRectAndFillWithBlack(rectLayer, rightRectCoords);  cropShadowCorners(rectLayer, bottomRectCoords, rightRectCoords);  applyGaussianBlur(rectLayer);  cropLayerCorners(layer);  //var upLayer = getLayerByName('up' + layer.name);  cropLayerCorners(canvasLayer, bottomRectCoords, rightRectCoords);  exposureLayerRect(layer, rightRectCoords);  return [rectLayer];}function exposureLayerRect(layer, coords) {  activeDocument.activeLayer = layer;  activeDocument.selection.select(coords);  // копия слоя с выделением  var idCpTL = charIDToTypeID("CpTL");  executeAction(idCpTL, undefined, DialogModes.NO);  exposureSelection();}function applyGaussianBlur(layer) {  activeDocument.activeLayer = layer;  activeDocument.selection.selectAll();  activeDocument.activeLayer.applyGaussianBlur(9);}function cropLayerCorners(layer) {  /*   (x, y) верхнего левого угла   (x, y) нижнего правого угла   */  var bounds = layer.boundsNoEffects;  var left = bounds[0].value;  var top = bounds[1].value;  var right = bounds[2].value;  var bottom = bounds[3].value;  activeDocument.activeLayer = layer;  cropCorner([right, top], [right - RIGHT_RECT_LEFT, top], ORIENTATION.DOWN);  cropCorner([right, bottom], [right - RIGHT_RECT_LEFT, bottom], ORIENTATION.UP);  activeDocument.activeLayer = this.getLayerByName(CANVAS_LAYER_NAME);  cropCorner([right, top], [right - RIGHT_RECT_LEFT, top], ORIENTATION.DOWN);  cropCorner([right, bottom], [right - RIGHT_RECT_LEFT, bottom], ORIENTATION.UP);}/** Обрезает углы у тени. */function cropShadowCorners(layer, bottomRectCoords, rightRectCoords) {  activeDocument.activeLayer = layer;  var left = bottomRectCoords[0][0];  var up = bottomRectCoords[0][1];  var right = bottomRectCoords[2][0];  var bottom = bottomRectCoords[2][1];  // нижний левый угол  cropCorner([left, bottom], [left + (bottom - up) * 2 / 3, bottom], ORIENTATION.UP);  left = rightRectCoords[0][0];  up = rightRectCoords[0][1];  right = rightRectCoords[2][0];  bottom = rightRectCoords[2][1];  // нижний левый угол  cropCorner([right, up], [right, up + (right - left)], ORIENTATION.LEFT);}/** Выдержка для выделения. */function exposureSelection() {  var desc4 = new ActionDescriptor();  desc4.putEnumerated(    stringIDToTypeID("presetKind"),    stringIDToTypeID("presetKindType"),    stringIDToTypeID("presetKindCustom")  );  desc4.putDouble(charIDToTypeID("Exps"), -2.000000);  desc4.putDouble(charIDToTypeID("Ofst"), 0.000000);  desc4.putDouble(stringIDToTypeID("gammaCorrection"), 1.000000);  executeAction(charIDToTypeID("Exps"), desc4, DialogModes.NO);}/** Заливает область выделения черным. */function createRectAndFillWithBlack(layer, coords) {  activeDocument.activeLayer = layer;  activeDocument.selection.select(coords);  app.foregroundColor.rgb.hexColor = 'ff0000';  //app.foregroundColor.model = ColorModel.RGB;  activeDocument.selection.fill(app.foregroundColor, ColorBlendMode.COLOR, '50');}function getLayerByName(name) {  for (var i = 0; i < activeDocument.artLayers.length; i++) {    var layer = activeDocument.artLayers[i];    if (layer.name === name) {      return layer;    }  }  alert('Layer ' + name + ' not found!');  return null;}function processLayers(document) {  var layer;  var fon;  var layersToProcess = [];  for (var j = 0; j < document.artLayers.length; j++) {    layer = document.artLayers[j];    if (LAYER_NAME_RE.test(layer.name)) {      // обрабатываем слой с картинкой      layersToProcess.push(layer);    }    if (layer.name === BG_LAYER_NAME) {      fon = layer;    }  }  // накладывает canvas на модули с картинами для текстуры (linear burn mode)  appendCanvasTextureToModules(layersToProcess);  for (j = 0; j < layersToProcess.length; j++) {    layer = layersToProcess[j];    // обрабатываем слой с картинкой    processModularLayer(layer, fon);  }}function appendCanvasTextureToModules(modules) {  makeCanvas();  var layer;  for (var j = 0; j < modules.length; j++) {    layer = modules[j];    addLayerToSelection(layer, j === 0);  }  invertSelection();  deleteSelection();  linearBurn();  deselect();}function deselect() {  activeDocument.selection.deselect();}function linearBurn() {  var idsetd = charIDToTypeID( "setd" );  var desc122 = new ActionDescriptor();  var idnull = charIDToTypeID( "null" );  var ref98 = new ActionReference();  var idLyr = charIDToTypeID( "Lyr " );  var idOrdn = charIDToTypeID( "Ordn" );  var idTrgt = charIDToTypeID( "Trgt" );  ref98.putEnumerated( idLyr, idOrdn, idTrgt );  desc122.putReference( idnull, ref98 );  var idT = charIDToTypeID( "T   " );  var desc123 = new ActionDescriptor();  var idMd = charIDToTypeID( "Md  " );  var idBlnM = charIDToTypeID( "BlnM" );  var idlinearBurn = stringIDToTypeID( "linearBurn" );  desc123.putEnumerated( idMd, idBlnM, idlinearBurn );  idLyr = charIDToTypeID( "Lyr " );  desc122.putObject( idT, idLyr, desc123 );  executeAction( idsetd, desc122, DialogModes.NO );}function deleteSelection() {  var idDlt = charIDToTypeID( "Dlt " );  executeAction( idDlt, undefined, DialogModes.NO );}function addLayerToSelection(layer, isFirst) {  var layerName = layer.name;  var idChnl = charIDToTypeID( "Chnl" );  var idTrsp = charIDToTypeID( "Trsp" );  var idfsel = charIDToTypeID( "fsel" );  var idnull = charIDToTypeID( "null" );  var idLyr = charIDToTypeID( "Lyr " );  var idT = charIDToTypeID( "T   " );  if (isFirst) {    var idsetd = charIDToTypeID( "setd" );    var desc98 = new ActionDescriptor();    var ref66 = new ActionReference();    ref66.putProperty( idChnl, idfsel );    desc98.putReference( idnull, ref66 );    var ref67 = new ActionReference();    ref67.putEnumerated( idChnl, idChnl, idTrsp );    ref67.putName( idLyr, layerName );    desc98.putReference( idT, ref67 );    executeAction( idsetd, desc98, DialogModes.NO );  } else {    var idAdd = charIDToTypeID( "Add " );    var desc99 = new ActionDescriptor();    var ref68 = new ActionReference();    ref68.putEnumerated( idChnl, idChnl, idTrsp );    ref68.putName( idLyr, layerName );    desc99.putReference( idnull, ref68 );    var ref69 = new ActionReference();    ref69.putProperty( idChnl, idfsel );    desc99.putReference( idT, ref69 );    executeAction( idAdd, desc99, DialogModes.NO );  }}// =====================================================================================================/** @param {[x,y][]]} points */function cropArea(points) {  _selectLasso();  _selectPoints(points);  _deleteArea();}function cropCorner(cornerPoint, trianglePoint, orientation, angle) {  // дефолтный угол – 45 градусов  angle = angle || Math.PI / 4;  var isHorizontal = cornerPoint[1] === trianglePoint[1];  // катет рядом с углом  var cat = Math.abs(isHorizontal ? cornerPoint[0] - trianglePoint[0] : cornerPoint[1] - trianglePoint[1]);  var otherCat = Math.tan(angle) * cat;  var thirdPoint = [];  if (isHorizontal) {    thirdPoint[0] = cornerPoint[0];    thirdPoint[1] = cornerPoint[1] + (orientation === ORIENTATION.DOWN ? 1 : -1) * otherCat;  } else {    thirdPoint[1] = cornerPoint[1];    thirdPoint[0] = cornerPoint[0] + (orientation === ORIENTATION.RIGHT ? 1 : -1) * otherCat;  }  cropArea([    trianglePoint,    cornerPoint,    thirdPoint  ]);}function _deleteArea() {  var idDlt = charIDToTypeID( "Dlt " );  executeAction( idDlt, undefined, DialogModes.NO );}function _selectLasso() {  // Выбираем полигональное лассо  // =======================================================  var select = new ActionDescriptor();  var ref30 = new ActionReference();  var idpolySelTool = stringIDToTypeID( "polySelTool" );  ref30.putClass( idpolySelTool );  select.putReference(    charIDToTypeID( "null" ),    ref30 );  var iddontRecord = stringIDToTypeID( "dontRecord" );  select.putBoolean( iddontRecord, true );  var idforceNotify = stringIDToTypeID( "forceNotify" );  select.putBoolean( idforceNotify, true );  executeAction(    charIDToTypeID( "slct" ),    select, DialogModes.NO );}function _selectPoints(points) {  var mainAction = new ActionDescriptor();  var ref31 = new ActionReference();  var idChnl = charIDToTypeID( "Chnl" );  var idfsel = charIDToTypeID( "fsel" );  ref31.putProperty( idChnl, idfsel );  mainAction.putReference( charIDToTypeID( "null" ), ref31 );  var pointsDescripts = new ActionDescriptor();  var pointsList = new ActionList();  var pointD;  var currentPoint;  for (var i = 0; i < points.length; i++) {    pointD = new ActionDescriptor();    currentPoint = points[i];    pointD.putUnitDouble(charIDToTypeID("Hrzn"), charIDToTypeID("#Pxl"), currentPoint[0]);    pointD.putUnitDouble(charIDToTypeID("Vrtc"), charIDToTypeID("#Pxl"), currentPoint[1]);    pointsList.putObject(charIDToTypeID("Pnt "), pointD);  }  pointsDescripts.putList(charIDToTypeID("Pts "), pointsList);  mainAction.putObject(charIDToTypeID( "T   " ), charIDToTypeID( "Plgn" ), pointsDescripts);  mainAction.putBoolean(charIDToTypeID( "AntA" ), true);  executeAction(charIDToTypeID( "setd" ), mainAction, DialogModes.NO);}/** ============================ RUN ================================ */WRITE_TO_CSV && createFile(PSD_FOLDER_PATH + OUT_SUBFOLDER, 'pictures.csv', CSV_ID);openFilesInDir(PSD_FOLDER_PATH);WRITE_TO_CSV && closeFile(CSV_ID);function getOutputFileName() {  var origName = getFileNameWoExtension();  var modulesSizes = getModulesSizes();  var newName = '' + modulesSizes.layerSizes.length + '_';  newName += (modulesSizes.overall.width > modulesSizes.overall.height ? 'h' : 'v') + '_';  newName += origName;  return newName;}function processDocument(doc) {  DO_RESIZE && doc.resizeImage(1640);  makeBackground();  var error = false;  processLayers(doc);  var outFileName = getOutputFileName();  saveJPEG(PSD_FOLDER_PATH + OUT_SUBFOLDER, outFileName);  var moduleSizes = getModulesSizes();  var str = outFileName + ',';  if (!moduleSizes.layerSizes.length) {    str += 'ERROR';    error = true;  } else {    str += moduleSizes.overall.width + ',' + moduleSizes.overall.height + ',';    for (var i = 0; i < moduleSizes.layerSizes.length; i++) {      var size = moduleSizes.layerSizes[i];      str += size.width + ',' + size.height;      if (i != moduleSizes.layerSizes.length - 1) {        str += ',';      }    }  }  WRITE_TO_CSV && writeToFile(str, CSV_ID);  return !error;}function rasterizeLayer() {  var idrasterizeLayer = stringIDToTypeID( "rasterizeLayer" );  var desc116 = new ActionDescriptor();  var idnull = charIDToTypeID( "null" );  var ref87 = new ActionReference();  var idLyr = charIDToTypeID( "Lyr " );  var idOrdn = charIDToTypeID( "Ordn" );  var idTrgt = charIDToTypeID( "Trgt" );  ref87.putEnumerated( idLyr, idOrdn, idTrgt );  desc116.putReference( idnull, ref87 );  executeAction( idrasterizeLayer, desc116, DialogModes.NO );}function placeImageOnNewLayer(imageFile) {  var c = charIDToTypeID;  var desc2 = new ActionDescriptor();  desc2.putPath(c("null"), new File(imageFile));  desc2.putEnumerated(c("FTcs"), c("QCSt"), c("Qcsa"));  var desc3 = new ActionDescriptor();  desc3.putUnitDouble(c("Hrzn"), c("#Pxl"), 0.000000);  desc3.putUnitDouble(c("Vrtc"), c("#Pxl"), 0.000000);  desc2.putObject(c("Ofst"), c("Ofst"), desc3);  executeAction(c("Plc "), desc2, DialogModes.NO);  rasterizeLayer();  return activeDocument.activeLayer;}function invertSelection() {  activeDocument.selection.invert();}/*function checkIfLayerExists(layerName) {  for (var i = 0; i < activeDocument.artLayers.length; i++) {    var layer = activeDocument.artLayers[i];    if (layer.name === layerName) {      return true;    }  }  return false;}*/function createTextureLayer(pathToTexture, layerName, firstOrLast) {  var layer = placeImageOnNewLayer(pathToTexture);  layer.name = layerName;  var traverseLayer;  var direction;  if (firstOrLast) {    traverseLayer = activeDocument.artLayers[0];    direction = ElementPlacement.PLACEBEFORE;  } else {    traverseLayer = activeDocument.artLayers[activeDocument.artLayers.length - 1];    direction = ElementPlacement.PLACEAFTER;  }  layer.move(traverseLayer, direction);  return layer;}function makeCanvas() {  return createTextureLayer(PATH_TO_CANVAS, CANVAS_LAYER_NAME, true);}function makeBackground() {  return createTextureLayer(PATH_TO_BACKGROUND, BG_LAYER_NAME, false);}